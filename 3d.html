<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Model Reconstruction</title>
    <style>
        * {
            font-family: monospace;
        }

        body {
            margin: 0;
            color: #d8d8d8;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            background-color: #181818;
            padding: 10px;
        }
    </style>
</head>
<body>
<div id="controls">
    <input type="file" id="file"><br>

    <label for="fov">FOV</label>
    <input type="number" id="fov" min="1" max="179" value="75"><br>

    <label for="centerX">Center X</label>
    <input type="number" id="centerX" min="0" max="1" step="0.1" value="0.5"><br>

    <label for="centerY">Center Y</label>
    <input type="number" id="centerY" min="0" max="1" step="0.1" value="0.5"><br>

    <label for="minZ">Min. Z</label>
    <input type="number" id="minZ" step="0.01" value="0"><br>

    <label for="maxZ">Max. Z</label>
    <input type="number" id="maxZ" step="0.01" value="1"><br>

    <button id="dl">File</button>

    <button id="camReset">Reset Camera</button>
</div>
<script src="lib/DATPARTOUT.js"></script>
<script type="module">
    import * as THREE from "./lib/three.module.js";
    import {OrbitControls} from "./lib/OrbitControls.js";

    function init() {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

        scene.background = new THREE.Color(0.2, 0.2, 0);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.zoomSpeed = 0.5;
        controls.rotateSpeed = 1;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 20;
        controls.enableKeys = false;
        controls.screenSpacePanning = true;
        controls.panSpeed = 5;

        const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            -1, 1, 1,
            1, -1, 1,
            1, 1, -1
        ]);
        const colors = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ]);

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3).setUsage(THREE.DynamicDrawUsage));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({size: 0.1, vertexColors: true});
        const mesh = new THREE.Points(geometry, material);

        scene.add(mesh);

        camera.position.z = -5;

        return {
            scene: scene,
            camera: camera,
            renderer: renderer,
            controls: controls,
            geometry: geometry
        };
    }

    const ctx = init();

    function animate() {
        requestAnimationFrame(animate);
        ctx.controls.update();
        ctx.renderer.render(ctx.scene, ctx.camera);
    }

    const fileElm = document.getElementById("file");
    const fovElm = document.getElementById("fov");
    const centerXElm = document.getElementById("centerX");
    const centerYElm = document.getElementById("centerY");
    const minZElm = document.getElementById("minZ");
    const maxZElm = document.getElementById("maxZ");

    let pointsEntry, colors, palette;

    fovElm.onchange = () => updateScene();
    centerXElm.onchange = () => updateScene();
    centerYElm.onchange = () => updateScene();
    minZElm.onchange = () => updateScene();
    maxZElm.onchange = () => updateScene();

    document.getElementById("dl").onclick = file;

    function file() {
        const points = getPoints(pointsEntry);

        let f = `ply
format ascii 1.0
element vertex ${points.length / 3}
property double x
property double y
property double z
property uchar red
property uchar green
property uchar blue
end_header
`;

        let vertex = [];

        for (const i in colors) {
            if (!colors.hasOwnProperty(i)) continue;

            if (i % 3 === 0 && i > 0) {
                f += `${vertex.join(' ')}\n`;
                vertex = [];
            }

            vertex[i % 3] = points[i];
            vertex[(i % 3) + 3] = Math.floor(colors[i] * 255);
        }
        f += `${vertex.join(' ')}\n`;

        console.log(f);
        return f;
    }

    function getPoints(entry) {
        const points = [];
        const centerX = parseFloat(centerXElm.value);
        const centerY = parseFloat(centerYElm.value);
        const fov = parseFloat(fovElm.value);
        const minZ = parseFloat(minZElm.value);
        const maxZ = parseFloat(maxZElm.value);

        for (const i in entry.data) {
            const fullWidth = entry.fullWidth;
            const u = i % fullWidth;
            if (u >= entry.width) continue;
            const v = Math.floor(i / fullWidth);
            const index = v * fullWidth + (fullWidth - u);

            if (!entry.data.hasOwnProperty(index)) continue;
            const d = entry.data[index];

            const fl = 0.5 / (Math.tan((fov / 2) * Math.PI / 180));

            let x = (u / entry.width) - centerX;
            let y = (v / entry.height) - centerY;
            let z = fl;

            const vLength = Math.sqrt((x * x) + (y * y) + (z * z));

            x /= vLength;
            y /= vLength;
            z /= vLength;

            //const dN = (((d / 0xFFFF) * ((1 - minZ) * maxZ)) + minZ) * 100;
            //const dN = (((d / 0xFFFF) * 1 - minZ) + minZ) * 100;
            //const dN = ((d * (1 - minZ) + 0xFFFF * minZ) / 0xFFFF) * 100;
            const dN = ((d + 0xFFFF * minZ) / 0xFFFF) * 100;
            //const dN = (d / 0xFFFF) * 100;

            points.push(x * dN, y * dN, z * dN - 50);
        }

        return points;
    }

    function getColors(entry, palette) {
        const colors = [];

        for (const i in entry.data) {

            let fullWidth = entry.width + entry.padding;
            const u = i % fullWidth;
            if (u >= entry.width) continue;
            const v = Math.floor(i / fullWidth);
            const index = v * fullWidth + (fullWidth - u);

            if (!entry.data.hasOwnProperty(index)) continue;
            const color = palette[entry.data[index]];

            colors.push(color.r / 255, color.g / 255, color.b / 255);
        }

        return new Float32Array(colors);
    }

    function updateScene() {
        const points = getPoints(pointsEntry);
        for (const i in points) {
            if (!points.hasOwnProperty(i) || !ctx.geometry.attributes.position.array.hasOwnProperty(i)) continue;
            ctx.geometry.attributes.position.array[i] = points[i];
        }

        ctx.geometry.attributes.position.needsUpdate = true;
        ctx.geometry.computeBoundingSphere();
    }

    document.getElementById("camReset").onclick = () => {
        ctx.controls.reset();
        ctx.camera.position.z = -5;
    };

    fileElm.onchange = () => {
        const f = fileElm.files[0];
        const r = new FileReader();

        r.readAsArrayBuffer(f);
        r.onload = () => {
            const datFile = new DATPARTOUT(r.result);
            pointsEntry = datFile.groups[212].entries[14];
            const points = getPoints(pointsEntry);
            palette = datFile.groups[1].entries[4].data.colors;
            const colorsEntry = datFile.groups[212].entries[3];
            colors = getColors(colorsEntry, palette);

            ctx.geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3).setUsage(THREE.DynamicDrawUsage));
            ctx.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            ctx.geometry.attributes.position.needsUpdate = true;
            ctx.geometry.attributes.color.needsUpdate = true;
            ctx.geometry.setDrawRange(0, points.length);

            updateScene(colors, points);
        };
    };

    animate();
</script>
</body>
</html>